> 在理解`yield`之前，首先我们得明白什么是`生成器`,理解生成器之前，我们需要知道什么是迭代器。(iterables-->Generators-->yield)

### Iterables

当我们创建一个list时，我们可以一个一个的读取它的成员。这种读取成员的方式称为迭代(iteration)

```python
myList = [1,2,3]
for i in myList:
    print(i)
```

myList是一个可迭代对象。当我们使用list创建一个list，那么它就是一个可迭代对象。
可以使用for……in在一个可迭代对象中。比如：lists,string,files
这些迭代是非常方便的，我们可以根据我们的需要来读取它们，但是这些值全部存储在内存中，并且的值的数量比较大时，这可能不是我们想要的。

### Generators(生成器)

生成器都是可迭代的，但是只能迭代一次！生成器的值不会存储在内存中，它时在运行时动态生成的。
和迭代器一样除了它时使用()而不是使用[]，并且该生成器不能再次执行，因为生成器只能使用一次。它是一个一个的计算值的。

### Yield

yield关键字类似于return，不同的是它会返回一个生成器。

'''python
def createGenerator():
    myList = range(3)
    for i in myList:
        yield i*i
'''

上面的例子没多大实际意义，当你的函数返回一组你只需要阅读一次的大量数据时，这个就很方便了。
当我们调用函数时，我们在函数体中写的代码并不会运行。该函数只返回一个生成器对象。当你每次使用生成器的时候，都会运行代码。
当我们第一次调用从函数创建的生成器对象时，它将从头开始运行函数中的代码，知道达到yield。然后，继续调用该循环，直到没有返回值。
当函数开始运行，我们认为该生成器是空的。还没运行到yield时。

* 在linux系统中，线程就是轻量级的进程，而协程也可以称为轻量级的线程即微线程。

### 进程和协程的异同

#### 相同点

* 我们可以把它们都看成是一种执行流，执行流可以挂起，并且后面可以在你挂起点地方恢复执行。

#### 不同点

* 执行流点调度者不同，进程是内核调动。而协程是在用户态调度，也就是说进程点上下文是在内核态保存恢复的。而协程是在用户态保存恢复的。很显然用户态的代价更低。
* 进程会被强占。而协程不会。也就是说协程如果不主动让出CPU，其他的协程，就没有执行的机会。
* 对内存的占用不同。实际上协程可以只需要占用4k的栈就足够了。而进程要占用的内存大得多。
* 从操作系统的角度来讲，多协程的程序是单进程。单协程。

### 协程和线程

* 线程之间需要切换的上下文成本相对协程来说是比较高的，尤其是在开启线程较多时，但协程切换的成本较低。
* 同样的线程的切换更多的是靠操作系统来控制，而协程的执行由我们自己控制。
