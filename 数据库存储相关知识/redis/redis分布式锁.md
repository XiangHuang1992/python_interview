
### 分布式锁

分布式锁本质上要实现的目标是在Redis里站一个坑，当别的进程也要来占时，发现以及被占，只能放弃或者稍后再试。

占坑使用`setnx(set if not exists)`指令，只允许被一个客户端占用。先来先占，用完了调用del命令释放占用。

但如果逻辑执行到中间出现异常，可能会导致del指令没有被调用，这样可能会陷入死锁，锁永远不会释放。

于是我们在拿到锁之后，再给锁加上一个过期时间，这样即使出现异常也可以保证锁在5s之后自动释放。

```shell
> setnx lock:codehole true
Ok
> expire lock:codehole 5
> del lock:codehole
(integer) 1
```

但是如果在setnx和expire之间服务器进程挂了，可能导致expire不会执行，也会导致死锁。因为setnx和expire两条指令不是原子指令。如果这两条指令可以一起执行，那么就不会产生这些问题。

redis2.8之后，加入了set指令的扩展参数。可以将setnx和expire组合在一起作为一个原子指令。

#### 超时问题

Redis的分布式锁不能解决超时问题，如何在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这个时候锁国旗了，第二个线程就会重新持有这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁释放了，第三个线程就会在第二个线程逻辑执行完之前拿到锁。

为了避免这个问题，Redis分布式锁不要用于较长时间的任务，如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。
